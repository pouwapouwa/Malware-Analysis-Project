\chapter{Ganiw}

\section{Introduction}

TODO: Introduction sur les botnets

Le \textit{sample} porté à l'étude porte le doux nom de \textbf{Ganiw} mais est
aussi connu sous les nom de \textbf{BillGates} ou de combinaisons comme
\textbf{LINUX.BACKDOOR.GATES}.\\
TODO:md5/sha1\\
Celui-ci semble avoir été étudié pour la première fois en février 2014
sur un site russe: \textit{\href{https://habrahabr.ru/post/213973/}
{Studying the BillGates Linux Botnet}}\footnotemark,
mais continue tout de même à être étudié et à être actif.
En effet, comme il sera expliqué plus amplement par la suite, celui-ci présente
des propriétés particulières.\\

Ce malware est présent uniquement sur les systèmes Linux.
Ce qui n'est pas anodin et sans lien quand à son utilisation: le
développement toujours plus important des objets connectés dans l'IoT
en fait une cible de choix. Linux ou les systèmes basés sur son noyau
(comme avec le projet Yocto\footnotemark) sont donc
des RTOS parfaits (TODO à reformuler) pour de petits appareils
car légers et open-sources et y ont le monopole.
De plus, ces objets connectés sont, en règle générale, peu protégés
(absence de firewall, mots de passe faibles,\ldots)
et non surveillés ou peu maintenus.
Ce sont donc des cibles de choix pour un malware de type \textit{BotNet},
comme \textbf{Ganiw}, pour mener des attaques réseaux de types DDOS par exemple.\\

La suite de cette étude va se faire sous 2 formes: une partie par
analyse statique du binaire et une autre par analyse dynamique,
permettant de confirmer et approfondir les données recueillies précédemment.

\footnotetext{Traduit depuis le russe}
\footnotetext{\url{https://www.yoctoproject.org/}}

\section{Étude -- Analyse statique}

\subsection{Outils d'analyse}

TODO: description outils et buts d'analyse statique

Contrairement à l'analyse statique dans son ensemble,
le travail effectué ne va pas chercher à debugger le programme
ou à y trouver les erreurs de programmation.
Le but, dans cette partie, va être d'obtenir des informations sur le
comportement du binaire lors de son exécution sans réellement l'exécuter.
N'ayant bien souvent que le binaire à disposition, l'étude se portera donc
sur du code asm (TODO: à reformuler) ou du code compilé,
en fonction des outils mis à disposition de l'analyste.\\

Ici, le travail de rétro-ingénierie se fera à partir du code assembleur et ce,
car aucun décompilateur (comme
\href{https://www.hex-rays.com/products/decompiler/}
{\textit{Hex-Rays Decompiler}}) n'était à disposition.
Les outils utilisés seront donc le debugger GNU
\href{https://www.sourceware.org/gdb/}{\textit{GDB}} et le désassembleur
\href{https://github.com/radare/radare2}{\textit{Radare2}},
qui sont tous les deux des logiciels libres.\\
TODO: parler du C++, not stripped

Afin de mieux suivre le fonctionnement et l'étude, pas à pas, de ce malware, une figure récapitulative de son comportement est présentée ici: fig~\ref{recap}.

\begin{figure}[!h]

  \centering
  \input{Fig2}
  \label{recap}
  \caption{Fonctionnement schématique de Ganiw}

\end{figure}

\subsection{Étude -- Main}

Le point d'entrée du binaire se fait au niveau de la fonction \textit{main}. Sans trop entrer dans les détails, il est aisé de remarquer la structure modulaire du malware~\ref{modulaire}.\\

\begin{figure}[!h]

  \centering
  \input{Fig1}
  \label{modulaire}
  \caption{Modules mis à disposition du malware}

\end{figure}

La fonction main commence donc par un ensemble de tests et d'initialisation de variables, de mises en place du système.\\
\subsubsection{Close all files descriptor}
Tout d'abord, le malware va fermer tous les points d'entrées ou de sorties sur/depuis lui, exceptés ceux standards (stdin, stdout et stderr).
\subsubsection{Decode and init first variables set}
La deuxième partie consiste en l'initialisation de certaines variables globales au programme, depuis une chaîne de caractères quelque peu étrange. Dans le sample étudié, celle-ci correspond à: \\"681A1C1543072E0140491F162F0B55545C55775F55565E57745E5D545652705D5E55585F70585C5659577D5\\C5F565C0423575B025A51720A56".\\
Une fonction de décodage, avec le mot clef 'Google', est appliquée à cette chaîne. Le code C++ associé est présent en annexes~\ref{C++}. Les informations obtenues sont alors stockées dans des flags (figure~\ref{first_flag}), qui serviront à définir le comportement futur du binaire.

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \multicolumn{1}{|l|}{\cellcolor{gray!20} g\_Iud77} & \multicolumn{3}{c|}{681A1C154 [\ldots] 0423575B025A51720A56} \\
    \hline
    \cellcolor{gray!20} g\_strMonitorFile & /usr/bin/.sshd & \cellcolor{gray!20} g\_uHiddenPt & 30000 \\
    \hline
    \cellcolor{gray!20} g\_iFileSize & 1223123 & \cellcolor{gray!20} g\_iHardStart & 772124 \\
    \hline
    \cellcolor{gray!20} g\_iSoftStart & 773152 & \cellcolor{gray!20} g\_strDoFun & 3010ad84e645e9 \\
    \hline
  \end{tabular}
  \caption{Valeurs des premiers flags initialisés}
  \label{first_flag}
\end{figure}

\subsubsection{Get module full path}

Ensuite, le chemin absolu du binaire va être récupéré à l'aide de l'appel système \textit{readlink} et du fichier \textit{$\backslash$proc$\backslash$\textbf{XX}$\backslash$exe} où \textit{\textbf{XX}} correspond au pid du processus courant.

\subsubsection{Integrity check}

Un test d'intégrité va être effectué à cette étape. La taille de l'exécutable va être récupérée à l'aide de l'appel système \textit{stat} et va être comparée au flag défini un peu plus tôt: \textit{g\_iFileSize}. Si les deux tailles sont différentes, alors le binaire fera une erreur de segmentation.

\subsubsection{Get Parent Path}

Puis, le chemin absolu vers le processus père de l'exécutable est récupéré, de la même manière que précédemment, mais avec la fonction \textit{getppid}.

\subsubsection{Anti-debug protection}

Un test est de nouveau effectué, mais, cette fois-ci, afin d'"empêcher" le débuggage du malware. Si le mot clef "gdb" est présent dans le chemin absolu du père, alors, le binaire fera une erreur de segmentation.

\subsubsection{Second variables set initialization}

La deuxième série d'initialisation de variables n'est pas obfusquée: les noms de variables et leurs contenus sont présentés dans le tableau suivant (figure~\ref{second_flag}).

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strSN & DBSecuritySpt & \cellcolor{gray!20} g\_strML & /tmp/moni.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDSN & selinux & \cellcolor{gray!20} g\_strGL & /tmp/gates.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDG & getty & \multicolumn{2}{c|}{}\\
    \hline
  \end{tabular}
  \caption{Valeurs des seconds flags initialisés}
  \label{second_flag}
\end{figure}

\subsubsection{Check of gates type}

Cette étape va définir le comportement du binaire, en fonction de son chemin absolu. En effet, celui-ci va être comparé au différentes valeurs présentes dans les flags définis plus tôt, afin de définir le contenu d'un nouveau flag: \textit{g\_iGatesType} (voir figure~\ref{gates_type}). TODO: comportement uaSystools\\

\begin{algorithm}[H]
  \label{gates_type}
  \caption{Initialisation du flag g\_iGatesType}
  \begin{algorithmic}[1]

    \State {path := GetModuleFullPath}
    \State {uaSystools := ['/bin/netstat', '/bin/lsof', '/bin/ps', '/bin/ss', \\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/bin/netstat','/usr/bin/lsof', '/usr/bin/ps', '/usr/bin/ss',\\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/sbin/netstat', '/usr/sbin/lsof', '/usr/sbin/ps', '/usr/sbin/ss']}
    \State {}
    \If {(path = g\_strMonitorFile)} \State {g\_iGatesType := 0} \Comment Module MainMonitor
    \Else
    \If {(path = "/usr/bin/bsd-port/getty")} \Comment Issu de g\_strBDG \State {g\_iGatesType := 2} \Comment Module MainBackdoor
    \Else
    \If {(path $\in$ uaSystools)} \State {g\_iGatesType := 3} \Comment Module MainSystool
    \Else \State {g\_iGatesType := 1} \Comment Module MainBeikong
    \EndIf \EndIf \EndIf

  \end{algorithmic}
\end{algorithm}

\subsubsection{Decode and init third variables set}

Tout comme lors de l'étape \textbf{Decode and init first varaibles set}, un ensemble de variables va être initialisé en fonction d'une valeur, rentrée en clair dans le binaire. Ici, celle-ci sera plus grande et a pour valeur:\\
TODO: explication + code C++""\\

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \multicolumn{1}{|l|}{\cellcolor{gray!20} g\_Iud76} & \multicolumn{3}{c|}{[\ldots]} \\
    \hline
    \cellcolor{gray!20} g\_strConnTgts & 115.231.168.64 & \cellcolor{gray!20} g\_iIsService & 1 \\
    \hline
    \cellcolor{gray!20} g\_iGatsPort & 13864 & \cellcolor{gray!20} g\_strForceNote & ssh4ckss \\
    \hline
    \cellcolor{gray!20} g\_iGatsFx & 1 & \cellcolor{gray!20} g\_iDoBackdoor & 1 \\
    \hline
  \end{tabular}
  \caption{Valeurs des derniers flags initialisés}
  \label{third_flag}
\end{figure}

\subsubsection{Module choice}

Enfin, le malware va charger un des modules, en fonction de la valeur du flag \textit{g\_iGatesType}, ou se mettre à jour si cela est possible.\\

Le pseudo-code de la fonction main, ainsi que de chacunes de ses étapes, est présent en annexes~\ref{main_algo}.\\

\subsection{Étude -- Beikong/Bill}

Le module Beikong (ou Bill) est le module d'installation mais également le premier module principal du botnet. Son rôle est, d'abord, de nettoyer le système en arrêtant et supprimant les potentielles instances de lui-même qui tournerait déjà sur le système, puis de mettre en place le démarrage automatique de son exécutable au lancement du système et, enfin, de réinstaller et démarrer les modules Backdoor et Monitor. Il s'occupe ensuite de la communication avec le serveur C\&C.
\newline

Pseudo-code :
\begin{itemize}
\item Arrête le module Monitor
\item Arrête le module Bill
\item Si la configuration le précise (booléen IsService à Vrai), créer un script i\textbf{/etc/init.d/DbSecuritySpt} et des liens symboliques \textbf{/etc/rc$i$.d/S97DbSecuritySpt} (avec $i$ allant de 1 à 5) vers ce script, permettant de lancer l'exécutable actuel au démarrage
\item Si la configuration le précise (booléen DoBackdoor à Vrai), arrête le module Backdoor et le réinstalle (dans \textbf{/usr/bin/bsd-port/getty}) et le relance
\item Si l'exécutable est exécuté en tant que root, indique la localisation du fichier du module Beikong dans \textbf{/tmp/notify.file} et installe/lance le module Monitor (dans \textbf{/usr/bin/.sshd})
\item Exécute MainProcess()
\end{itemize}

%Depuis le main, HGrd9 écrit DbSecuritySpt (g\_strSN), selinux (g\_strBSDN), getty (g\_strBDG), /tmp/moni.lod (g__strML), (g__strGL) avec 'nkfsd8' qui écrit tmp, 'Kusdf9' qui écrit moni, tRd76 qui écrit lod. KDS87y inutil !! 0sdku6 '/tmp/moni.lod'
%\\

\subsection{Étude -- Backdoor}
Le module Backdoor est le deuxième module principal du botnet. Il s'occupe de remplacer quelques outils systèmes classiques par son exécutable pour cacher ses traces. Il s'occupe ensuite d'exécuter les ordres venant du serveur C\&C, reçus par le biais du module Bill.\newline

Pseudo-code :
\begin{itemize}
\item Inscrit le pid du processus actuel dans le fichier \textbf{/usr/bin/bsd-port/getty.lock} et lock le fichier
\item Créer un script \textbf{/etc/init.d/selinux} et des liens symboliques \textbf{/etc/rc$i$.d/S99selinux} (avec $i$ allant de 1 à 5) vers ce script, permettant de lancer l'exécutable actuel (\textbf{/usr/bin/bsd-port/getty}) au démarrage
\item Copie et remplace les outils systèmes $netstat$, $lsof$, $ps$ et $ss$ dans les dossiers \textbf{/bin/}, \textbf{/usr/bin/} et \textbf{/usr/sbin/}
\item Exécute MainProcess()
\end{itemize}

\subsection{Étude -- Autres modules}
\subsubsection{Monitor}
Le module Monitor s'occupe de vérifier que le module Bill reste en vie, et de le relancer si il ne l'est plus.

Pseudo-code :
\begin{itemize}
\item Écrit le pid du processus actuel dans le fichier \textbf{/tmp/moni.lod} et lock le fichier
\item Récupère la localisation du fichier Beikong dans \textbf{/tmp/notify.file} et supprime le fichier
\item Démarre un thread "CThreadMonGates" qui vérifie, toutes les 60 secondes, que le fichier \textbf{/tmp/gates.lock} à un lock actif (et donc que le module Bill est toujours vivant) et relance le module Bill si ce n'est pas le cas
\item Boucle à l'infini
\end{itemize}

\subsubsection{Systool}
Le module Systool est le module qui s'exécute lorsque l'exécutable est mis à la place d'un des outils systèmes $netstat$, $lsof$, $ps$ ou $ss$. Son rôle est de filtrer les sorties des outils qu'il remplace pour cacher les parties qui révèlent la présence du module Backdoor.\newline

Pseudo-code :
\begin{itemize}
\item Déduit le chemin de l'outil système original associé, en le dérivant du nom de l'exécutable actuel
\item Si l'outil a été trouvé, on récupère le chemin complet de l'exécutable du module Backdoor ainsi que la valeur du HiddenPort, on exécute l'outil système avec les arguments passés en paramètres et on filtre la sortie en n'affichant pas les références aux chemin et port récupérer précédemment
\end{itemize}

\subsubsection{Update}
TODO

\section{Étude -- Analyse dynamique}

inetsim gdb strace wireshark/tcpdump ++ mise en place vm/dns server/...

Mise en place d'un environnement de travail $+$ outils utilisés (lemon ?)\\
→ crontab trouvé dans l'analyse statique --> fonctionnement fichier rc.

\section{Conclusion}
