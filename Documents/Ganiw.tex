\chapter{Ganiw}

\section{Introduction}

Le \textit{sample} porté à l'étude est appelé \textbf{Ganiw} mais est
aussi connu sous les nom de \textbf{BillGates} ou de combinaisons comme
\textbf{LINUX.BACKDOOR.GATES} par les antivirus .\\
Celui-ci semble avoir été étudié pour la première fois en Février 2014
dans un post de \textit{ValdikSS} sur le site \textit{\foreignlanguage{russian}{Хабрахабр}} : \textit{\href{https://habrahabr.ru/post/213973/}
{Studying the BillGates Linux Botnet}}\footnote{Traduit depuis le russe},
mais continue tout de même à être étudié et à être actif.\\

Le malware Ganiw a été réalisé en C++ et pensé de manière à
être modulaire et portable.
Ce malware visait, à l'origine, uniquement les systèmes Linux,
mais a été porté plus tard sur les systèmes Windows
\footnote{\url{https://thisissecurity.net/2015/09/30/when-elf-billgates-met-windows/}}\\.
Le choix des systèmes Linux n'est pas sans lien avec le développement
toujours plus important des objets connectés dans l'"Internet of Things" (IoT).
En effet, une grande partie des systèmes embarqués prenant part à l'IoT fonctionnent
sur des distributions de GNU/Linux (voir OpenWrt
\footnote{\url{https://openwrt.org/}}  ou le projet Yocto
\footnote{\url{https://www.yoctoproject.org/}}).
Ces objets connectés sont, de manière générale, peu ou mal protégés
(absence de firewall, mots de passe faibles,\ldots) et non surveillés ou peu maintenus.
Ce sont donc des cibles de choix pour la création de \textit{botnets},
comme tente de le faire le malware \textbf{Ganiw}, pour mener des attaques
de types DDOS\footnote{Distributed Denial-Of-Service} par exemple.

\subsection{Les outils}

Les principaux outils utilisés pour réaliser cette analyse ont été
le logiciel de virtualisation \href{https://www.virtualbox.org/}{\textit{VirtualBox}},
le débugueur GNU \href{https://www.sourceware.org/gdb/}{\textit{GDB}},
l'utilitaire \href{https://github.com/strace/strace}{\textit{strace}},
l'analyseur de paquets \href{https://www.wireshark.org/}{\textit{Wireshark}},
le désassembleur \href{https://github.com/radare/radare2}{\textit{Radare2}} et
et le simulateur de services internet \href{http://www.inetsim.org/}{\textit{INetSim}}
qui sont des logiciels libres.

\section{Analyse}

Avant toute chose, voilà, ci-dessous, le SHA-256 du sample analysé :
\begin{lstlisting}
94f5fd896a526427a5ef1de37725e6eae3a06af3da098547f0adcfdd34fbfd2a
\end{lstlisting}

\subsection{Analyse basique}

Pour commencer, il est bon d'utiliser l'utilitaire $file$ pour en apprendre un
peu plus sur l'exécutable :
\begin{lstlisting}
ganiw:  ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked,
        for GNU/Linux 2.2.5, not stripped
\end{lstlisting}
C'est donc un exécutable au format ELF (Executable and Linkable Format) 32-bit pour Linux.\\
Il est intéressant de remarquer que l'exécutable est lié statiquement et surtout
qu'il n'a pas été strip (ce qui va nous permettre d'obtenir des informations
utiles telles que les noms de fonctions, méthodes ou variables potentiellement
utilisées par le programme et donc nous permettre de comprendre plus facilement
comment fonctionne le malware).\\

Un petit coup de \textit{strings} nous permet de trouver quelques indices sur
ce qui se passe lors de l'exécution du binaire, par exemple :
\begin{lstlisting}
$> strings ganiw | less
[...]
/proc/meminfo
MemTotal:         %d kB
/proc/stat
cpu %llu %llu %llu %llu
/proc/net/dev
%7s %llu %lu %lu %lu %lu %lu %lu %lu %llu %lu %lu %lu %lu %lu %lu %lu
/proc/cpuinfo
processor
/proc/net/arp
%16s 0x%d 0x%d %20s %s
%2x:%2x:%2x:%2x:%2x:%2x
/proc/net/route
%5s %8x %8x %s
cpu MHz
cpu MHz         : %d.%d
vector::_M_insert_aux
%5s %s
/bin/netstat
/bin/lsof
/bin/ps
/bin/ss
/usr/bin/netstat
/usr/bin/lsof
/usr/bin/ps
/usr/bin/ss
/usr/sbin/netstat
/usr/sbin/lsof
/usr/sbin/ps
/usr/sbin/ss
GLIBCXX_FORCE_NEW
update_temporary
mkdir -p %s
cp -f %s %s
/tmp/notify.file
/usr/bin/
.lock
[...]
\end{lstlisting}

L'outil \textit{strings} renvoit un grand nombre de chaînes de caractères,
dont certaines intéressantes. Il y a peu de chance que l'exécutable soit
packé ou compressé étant donné le nombre élevé de chaînes
compréhensibles et claires présentes.\\

L'utilisation de \textit{nm} permet en revanche de voir clairement les symboles présents
dans le binaire. Puisque le malware a été réalisé en C++, il est préférable
d'utiliser l'option \textit{-C} de \textit{nm} pour pouvoir lire facilement
le nom des méthodes.\\
Voici, par exemple, ce qu'il est possible de trouver en utilisant \textit{nm} :
\begin{lstlisting}
$> nm -C ganiw | grep Main
080623f2 T MainBeikong()
08061c48 T MainMonitor()
080620ac T MainProcess()
08061d3c T MainSystool(int, char**)
08062304 T MainBackdoor()
08089398 T CThreadTns::ProcessMain()
08083ffe T CThreadDoFun::ProcessMain()
080883fc T CThreadShell::ProcessMain()
08089a3e T CThreadUpdate::ProcessMain()
0807fb5c T CThreadAtkCtrl::ProcessMain()
080865b4 T CThreadHttpGet::ProcessMain()
08087552 T CThreadLoopCmd::ProcessMain()
08087ac0 T CThreadRecycle::ProcessMain()
08087966 T CThreadMonGates::ProcessMain()
08086f2c T CThreadKillChaos::ProcessMain()
08088740 T CThreadTaskGates::ProcessMain()
08083aae T CThreadConnection::ProcessMain()
080848d8 T CThreadFakeDetect::ProcessMain()
08083870 T CThreadClientStatus::ProcessMain()
08083e22 T CThreadFXConnection::ProcessMain()
08088628 T CThreadShellRecycle::ProcessMain()
080808a6 T CThreadKernelAtkExcutor::ProcessMain()
08080db8 T CThreadNormalAtkExcutor::ProcessMain()
08066a8e T CManager::MainProcess()
08066788 T CManager::ZXMainProcess()
08100900 r MainSystool(int, char**)::C.1203
081008c0 r MainSystool(int, char**)::C.1206
\end{lstlisting}
\ \\
Quelques noms intéressants apparaissent, il ne reste plus qu'à aller jeter un
oeil de plus près.\\

Une analyse plus poussée est nécessaire pour avoir une idée concrète de ce que
fait le malware étudié. Pour l'instant, impossible de savoir quels sont les
liens entre les différentes fonctions et méthodes repérées précédemment.
L'analyse continue donc avec Radare2, pour désassembler
le binaire, VirtualBox, GDB et strace pour obtenir des valeurs à des endroits
clés ou la liste des appels systèmes utilisés pendant l'exécution du malware.\\

Afin de faciliter la compréhension des relations qu'entretiennent les
différents modules entre eux, une figure récapitulative est présentée ci-dessous :\\
\begin{figure}[!h]

  \centering
  \input{Fig2}
  \label{recap}
  \caption{Fonctionnement schématique de Ganiw}

\end{figure}

\newpage

\subsection{Main}

Le point d'entrée du binaire se fait au niveau de la fonction \textit{main}.
Sans trop entrer dans les détails, il est aisé de remarquer la structure
modulaire du malware~\ref{modulaire}.\\
\begin{figure}[!h]

  \centering
  \input{Fig1}
  \label{modulaire}
  \caption{Modules mis à disposition du malware}

\end{figure}

La fonction main commence donc par un ensemble de tests et d'initialisations de
variables globales, afin de mettre en place le système.\\
Ci-dessous sont décrites précisément chacune de ces étapes,
mais un pseudo-code récapitulatif peut être trouvé en annexes~\ref{main_algo}.
\subsubsection{Close all files descriptor}
Tout d'abord, le malware va fermer les descripteurs de fichier compris entre
3 et 1023, laissant l'entrée standard, la sortie standard et l'erreur standard
(stdin, stdout et stderr) accessibles.
\subsubsection{Decode and init first variables set}
La deuxième partie consiste en l'initialisation de certaines variables globales,
depuis une chaîne de caractères quelque peu étrange. Dans le sample étudié,
celle-ci correspond à: \\
"681A1C1543072E0140491F162F0B55545C55775F55565E57745E5D545652705D5E55585F70585C
5659577D5\\C5F565C0423575B025A51720A56".\\

Une fonction de décodage (un simple XOR avec les octets de la clé),
avec la clé 'Google', est appliquée à cette chaîne. Le code C++ associé est
présent en annexes~\ref{C++}. Les informations obtenues sont alors stockées
dans des variables (figure~\ref{first_flag}), qui serviront à définir le
comportement futur du binaire.

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \multicolumn{1}{|l|}{\cellcolor{gray!20} g\_Iud77} &
    \multicolumn{3}{c|}{681A1C154 [\ldots] 0423575B025A51720A56} \\
    \hline
    \cellcolor{gray!20} g\_strMonitorFile & /usr/bin/.sshd &
    \cellcolor{gray!20} g\_uHiddenPt & 30000 \\
    \hline
    \cellcolor{gray!20} g\_iFileSize & 1223123 &
    \cellcolor{gray!20} g\_iHardStart & 772124 \\
    \hline
    \cellcolor{gray!20} g\_iSoftStart & 773152 &
    \cellcolor{gray!20} g\_strDoFun & 3010ad84e645e9 \\
    \hline
  \end{tabular}
  \caption{Valeurs des premières variables initialisées}
  \label{first_flag}
\end{figure}

\subsubsection{Get module full path}

Ensuite, le chemin absolu du binaire va être récupéré à l'aide de l'appel
système \textit{readlink} et du fichier
\textit{$\backslash$proc$\backslash$\textbf{XX}$\backslash$exe} où
\textit{\textbf{XX}} correspond au pid du processus courant.

\subsubsection{Integrity check}

Un test d'intégrité va être effectué à cette étape. La taille de l'exécutable
va être récupérée à l'aide de l'appel système \textit{stat} et va être comparée
à la valeur de la variable définie un peu plus tôt: \textit{g\_iFileSize}.
Si les deux tailles sont différentes, alors le binaire produit
une erreur de segmentation.

\subsubsection{Get Parent Path}

Puis, le chemin absolu vers le processus père de l'exécutable est récupéré,
de la même manière que précédemment, mais avec la fonction \textit{getppid}.

\subsubsection{Anti-debug protection}

Un test est de nouveau effectué, mais, cette fois-ci,
afin d'"empêcher" le débugage du malware.
Si la chaîne de caractères "gdb" est présente dans le chemin absolu
du processus père, alors le binaire produit une erreur de segmentation.

\subsubsection{Second variables set initialization}

La deuxième série d'initialisation de variables n'est pas obfusquée:
le nom des variables et leurs contenus sont présentés
dans le tableau suivant (figure~\ref{second_flag}).

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strSN & DBSecuritySpt &
    \cellcolor{gray!20} g\_strML & /tmp/moni.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDSN & selinux &
    \cellcolor{gray!20} g\_strGL & /tmp/gates.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDG & getty & \multicolumn{2}{c|}{}\\
    \hline
  \end{tabular}
  \caption{Valeurs des secondes variables initialisées}
  \label{second_flag}
\end{figure}

\subsubsection{Check of gates type}

Cette étape va définir le comportement du binaire,
en fonction de son chemin absolu.
En effet, celui-ci va être comparé au différentes valeurs présentes
dans les variables définies plus tôt, afin de définir le contenu d'une
nouvelle variable: \textit{g\_iGatesType} (voir figure~\ref{gates_type}).

\begin{algorithm}[H]
  \label{gates_type}
  \caption{Initialisation de la variable g\_iGatesType}
  \begin{algorithmic}[1]

    \State {path := GetModuleFullPath}
    \State {uaSystools := ['/bin/netstat', '/bin/lsof', '/bin/ps', '/bin/ss', \\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/bin/netstat',
        '/usr/bin/lsof', '/usr/bin/ps', '/usr/bin/ss',\\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/sbin/netstat',
        '/usr/sbin/lsof', '/usr/sbin/ps', '/usr/sbin/ss']}
    \State {}
    \If {(path = g\_strMonitorFile)} \State {g\_iGatesType := 0}
    \Comment Module MainMonitor
    \Else
    \If {(path = "/usr/bin/bsd-port/getty")} \Comment Issu de g\_strBDG
    \State {g\_iGatesType := 2} \Comment Module MainBackdoor
    \Else
    \If {(path $\in$ uaSystools)} \State {g\_iGatesType := 3}
    \Comment Module MainSystool
    \Else \State {g\_iGatesType := 1} \Comment Module MainBeikong
    \EndIf \EndIf \EndIf

  \end{algorithmic}
\end{algorithm}

\subsubsection{Decode and init third variables set}

Tout comme lors de l'étape \textbf{Decode and init first variables set},
un ensemble de variables va être initialisé en fonction d'une chaîne de
caractères, rentrée en clair dans le binaire.\\
En ce qui concerne ces variables, il y a deux configurations possibles :
une première configuration pour le module Backdoor et une seconde
pour le module Beikong. Ces deux configurations sont stockées chiffrées
(à l'aide de l'algorithme de chiffrement RSA) dans le binaire
et sont déchiffrées avant d'être parsées.\\

Un test d'intégrité est fait
sur les configurations en comparant la valeur des 14 premiers octets du
hash MD5 de la chaîne de caractères contenant les deux configurations chiffrées
à la valeur stockée dans la variable globale g\_strDoFun.\\
\newpage
Ces deux configurations sont les suivantes :

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strConnTgts & 115.28.206.48 &
    \cellcolor{gray!20} g\_iIsService & 1 \\
    \hline
    \cellcolor{gray!20} g\_iGatsPort & 25000 &
    \cellcolor{gray!20} g\_strForceNote & -== Love AV ==- \\
    \hline
    \cellcolor{gray!20} g\_iGatsFx & 1 & \cellcolor{gray!20} g\_iDoBackdoor & 1 \\
    \hline
  \end{tabular}
  \caption{Valeurs des dernières variables globales initialisés
    pour le module Bill}
  \label{third_flag}
\end{figure}

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strConnTgts & www.i0cc.com &
    \cellcolor{gray!20} g\_iIsService & 1 \\
    \hline
    \cellcolor{gray!20} g\_iGatsPort & 6001 &
    \cellcolor{gray!20} g\_strForceNote & -== Love AV ==- \\
    \hline
    \cellcolor{gray!20} g\_iGatsFx & 1 &
    \cellcolor{gray!20} g\_iDoBackdoor & 1 \\
    \hline
  \end{tabular}
  \caption{Valeurs des dernières variables globales
    initialisés pour le module Backdoor}
  \label{third_flag}
\end{figure}


\subsubsection{Module choice}

Enfin, le malware va charger un des modules, en fonction de la valeur de la
variable \textit{g\_iGatesType}, ou lancer une mise à jour si l'exécutable
porte le nom \textbf{update\_temporary}.\\
Tous les modules à l'exception des modules Monitor et Systool commencent par
invoquer la fonction $daemon$ (avec les arguments (1, 0)) qui détache le
processus actuel du terminal actif en effectuant un $fork$ puis
en redirigeant stdin, stderr et stdout dans /dev/null.\\

\subsection{Module Beikong/Bill}

Le module Beikong (ou Bill) est le module d'installation mais également
le premier module principal du botnet.\\
Son rôle est, d'abord, de nettoyer
le système en arrêtant et supprimant les potentielles instances de lui-même
qui tourneraient déjà sur le système, puis de mettre en place le démarrage
automatique de son exécutable au lancement du système (en manipulant la crontab)
et, enfin, de réinstaller et démarrer les modules Backdoor et Monitor.
Il communique également avec un serveur "command and control" (C\&C).
\newline

\begin{algorithm}[H]
  \label{beikong_code}
  \caption{Pseudo-code Beikong}
  \begin{algorithmic}[1]
    \State Arrête le module Monitor
    \State Arrête le module Bill
    \If {IsService}
      \State Créé un script
        \textbf{/etc/init.d/DbSecuritySpt} et des liens symboliques
        \textbf{/etc/rc$i$.d/S97DbSecuritySpt} (avec $i$ allant de 1 à 5)
        vers ce script, permettant de lancer l'exécutable actuel au démarrage
    \EndIf
    \If {DoBackdoor}
      \State Arrête le module Backdoor, le réinstalle
        (dans \textbf{/usr/bin/bsd-port/getty}) et le relance
    \EndIf
	  \If {IsRoot()}
      \State Indique la localisation du fichier du module Beikong dans
        \textbf{/tmp/notify.file} et installe/lance le module Monitor
        (dans \textbf{/usr/bin/.sshd})
    \EndIf
    \State Exécute MainProcess()
  \end{algorithmic}
\end{algorithm}

\newpage

\subsection{Module Backdoor}
Le module Backdoor est le deuxième module principal du botnet. Il s'occupe
de remplacer quelques outils systèmes classiques par son exécutable pour
cacher ses traces. Il communique lui aussi avec un serveur C\&C.\newline

\begin{algorithm}
  \label{backdoor_code}
  \caption{Pseudo-code Backdoor}
  \begin{algorithmic}[1]
    \State Inscrit le pid du processus actuel dans le fichier
      \textbf{/usr/bin/bsd-port/getty.lock} et lock le fichier
    \State Créer un script \textbf{/etc/init.d/selinux} et des liens symboliques
      \textbf{/etc/rc$i$.d/S99selinux} (avec $i$ allant de 1 à 5) vers ce
      script, permettant de lancer l'exécutable actuel
      (\textbf{/usr/bin/bsd-port/getty}) au démarrage
    \State Copie et remplace les outils systèmes $netstat$, $lsof$, $ps$ et $ss$
      dans les dossiers \textbf{/bin/}, \textbf{/usr/bin/}
      et \textbf{/usr/sbin/}
    \State Exécute MainProcess()
  \end{algorithmic}
\end{algorithm}

\subsection{MainProcess, capacité d'attaque et
  communication avec les serveurs C\&C}
Dans les modules précédents on finit dans les deux cas par exécuter
la fonction MainProcess(). Cette fonction constitue la partie active du botnet.

\begin{algorithm}
  \label{mainprocess_code}
  \caption{Pseudo-code MainProcess()}
  \begin{algorithmic}[1]
    \State Initialise DNSCache (parse \textbf{/etc/resolv.conf}, utilisé pour la
      résolution de noms de domaine)
    \State Initialise ConfigDoing (parse \textbf{conf.n} qui se trouve
      dans le dossier courant)
    \State Initialise CmdDoing (parse \textbf{cmd.n} qui se trouve
      dans le dossier courant)
    \State Initialise StatBase (GetOS, GetCpuSpd, CpuUse, NetUse, GetMemSize)
    \State Initialise ProvinceDns (liste de DNS utilisés pour l'amplification)
    \State Essaye de charger \textbf{/usr/lib/xpacket.ko} avec
      system("insmod /usr/lib/xpacket.ko")
    \State Initialise CAmpResource (en lisant le fichier
      \textbf{/usr/lib/libamplify.so})
    \State Initialise CManager (démarrage des threads principaux
      et de la communication au C\&C)
  \end{algorithmic}
\end{algorithm}

\subsubsection{Communication avec le serveur C\&C}
Le botnet à besoin de communiquer avec un ou plusieurs serveurs C\&C pour
pouvoir agir.\\
La communication au C\&C peut se faire dans les deux sens : soit le client
se connecte au serveur C\&C, soit le serveur C\&C se connecte au client.
Le choix est fait en fonction du paramètre de configuration g\_GatsIsFx;
dans notre cas le client se connecte au serveur (ce qui est préférable
étant donné que beaucoup de routeurs font du NAT par défaut,
ce qui empêche les connexions sur des ports arbitraires depuis l'extérieur).\\

La communication s'effectue par le biais d'une ou plusieurs connexions TCP/IP
en direction ou depuis les IPs définies dans g\_strConnTgts
et sur le port défini dans g\_iGatsPort.\newline
Dans le cas où g\_iGatsIsFX est vrai, un thread représenté par
la classe "CThreadFXConnection" est crée pour établir et gérer chaque connection
aux différents serveurs C\&C.\newline
En revanche, dans le cas où g\_iGatsIsFX est faux, alors le module exécute
la méthode CManager$::$ZXMainProcess() qui va simplement créer une socket,
la bind sur le port g\_iGatsPort et se mettre en écoute, de manière à accepter
toutes les connexions entrantes sur ce port.\newline
Dans les deux cas, le module fini par appeler la méthode
CManager$::$ConnectionProcess() qui s'occupe de communiquer avec le serveur C\&C
et de faire passer les commandes reçues au thread en charge de l'exécution des
commandes, par le biais d'un objet de type
"CThreadSignaledMessageList$<$CCmdMsg$>$".\newline

Le protocole de discussion est simple: après avoir établi une connexion avec un
serveur C\&C, le client commence par envoyer des informations sur lui-même
(à savoir, une copie de son objet CConfigDoing actuel) ainsi que sur la machine
(telles que le nombre de cœurs présents sur la machine,
la fréquence de fonctionnement des cœurs, la quantité de RAM disponible sur
la machine, la version du noyau linux ou encore l'IP de la machine
dans le réseau local) en appelant la méthode CManager$::$MakeInitResponse().
Ensuite le client se met en attente de commandes en appelant la méthode
CManager$::$RecvCommand().\\

\newpage

Les paquets de commande envoyés par le serveur C\&C sont de la forme :\\
\newline
\begin{bytefield}[bitwidth=3.5em]{8}
\bitheader{0-7} \\
\bitbox{4}{ID de la commande} & \bitbox{4}{Taille du champ paramètres} &
\bitbox{4}{Paramètres}
\end{bytefield} \\

Plusieurs commandes sont disponibles :
\begin{figure}[h!]
 \centering
 \begin{tabular}{|l|c|}
    \hline
    \cellcolor{gray!20} Id de la commande & \cellcolor{gray!20} Description \\
    \hline
    \cellcolor{gray!0} 0x1 & Démarre une attaque sur une ou plusieurs cibles \\
    \hline
    \cellcolor{gray!0} 0x2 & Arrête les attaques ou mises à jour en cours \\
    \hline
    \cellcolor{gray!0} 0x3 & Modifie la configuration du module \\
    \hline
    \cellcolor{gray!0} 0x5 & Démarre une mise à jour du client \\
    \hline
    \cellcolor{gray!0} 0x7 & Mets à jour l'actuel objet de type CCmdDoing \\
    \hline
    \cellcolor{gray!0} 0x8 & DoFakeDetect (Contrôler l'IP source) \\
    \hline
    \cellcolor{gray!0} 0x9 &  Demande l'accès à un reverse shell en tant
    que root sur le client \\
    \hline
  \end{tabular}
  \caption{Liste des commandes disponibles}
  \label{cmds}
\end{figure}
\ \\
Le thread représenté par la classe "CThreadTaskGates" s'occupe, en parallèle,
d'exécuter la liste de commandes qu'il peut trouver dans la liste
des commandes mentionnée précédemment. Il vérifie d'abord que des commandes
ont été reçues et, si c'est le cas, exécute le handler associé à la commande,
puis recommence indéfiniment.\newline

\subsubsection{Attaques normales}
Le botnet peut mener plusieurs attaques de type DDOS en utilisant
des sockets "raw" depuis le mode utilisateur.\newline
Tout se déroule dans la méthode CThreadAtkCtrl$::$StartNormalSubTask().\newline
Au total, 11 types d'attaques sont recensées dans ce sample,
dont 3 qui ne semblent pas être totalement implémentées:
\begin{itemize}
\item[$\bullet$] CAttackCompress : Attaque TCP flood avec header TCP choisi
  (utile pour les fragment attack / Teardrop)
\item[$\bullet$] CAttackSyn : Attaque TCP type SYN flood
\item[$\bullet$] CAttackUdp : Attaque type UDP packet flood
\item[$\bullet$] CAttackDns : Attaque type DNS flood (pour l'attaque de sous-domaines DNS)
\item[$\bullet$] CAttackAmp : Attaque type DNS amplification
\item[$\bullet$] CAttackPrx : Attaque de type indéterminé faisant usage de requêtes DNS
\item[$\bullet$] CAttackIcmp : Attaque type ICMP-Request flood
\item[$\bullet$] CTcpAttack : Attaque type TCP flood
  (connexion, envoi de 5000 octets, déconnexion)
\item[$\bullet$] CAttackCc : Attaque pas entièrement implémentée
  (une attaque de type HTTP request flood d'après les seules traces visibles)
\item[$\bullet$] CAttackIe : Attaque non implémentée
\item[$\bullet$] CAttackTns : Attaque non implémentée
\end{itemize}
\ \\
Le déroulement des attaques est similaire pour toutes ces attaques.
Les classes sont toutes descendantes d'une classe CPacketAttack qui implémente
des méthodes virtuelles $UpdateCurVariant$ (chargée de mettre à jours certains
paramètres tels que l'IP source, le port source ou le numéro de séquence
du prochain paquet), $MakePacket$ (qui s'occupe de forger entièrement
le paquet à envoyer) et $Do$ (qui exécute une itération de l'attaque,
en appelant $UpdateCurVariant$, $MakePacket$, $SendPacket$ typiquement)
que chaque classe d'attaque personnalise en fonction des besoins.\newline

\newpage

\subsubsection{Attaques noyaux}
Le botnet est également capable de lancer des attaques depuis le noyau grâce à
l'outil \textit{pktgen}, qui permet de générer des paquets très rapidement.\newline
Tout se déroule dans la méthode CThreadAtkCtrl$::$StartKernalSubTask()
(et la faute de frappe pour Kernal n'est pas de nous).\\

La configuration de l'outil se fait en trois étapes :\\
\begin{itemize}
\item[$\bullet$]Pour chaque cœur du CPU de la machine,
  un fichier \textbf{/proc/net/pktgen/kpktgend\_$i$} (où $i$ est
  le numéro du cœur) est créé. Le contenu de ces fichiers est le suivant :
\begin{lstlisting}
rem_device_all
add_device eth%d
max_before_softirq 10000
\end{lstlisting}
\item[$\bullet$]Pour chaque cœur du CPU de la machine, un fichier
  \textbf{/proc/net/pktgen/eth$i$} (où $i$ est le numéro du cœur) est créé.
  Le contenu de ces fichiers est le suivant :
\begin{lstlisting}
count 0
clone_skb 0
delay 0
TXSIZE_RND
min_pkt_size %d
max_pkt_size %d
IPSRC_RND
src_min %s
src_max %s
UDPSRC_RND
udp_src_min %d
udp_src_max %d
dst %s
udp_dst_min %d
udp_dst_max %d
dst_mac %02x:%02x:%02x:%02x:%02x:%02x//adresse MAC de la passerelle obtenue de g_statBase
is_multi %d //nombre de cibles
multi_dst %s //si l'attaque se fait vers plusieurs adresses, elles sont specifiees ici
pkt_type %d
dns_domain %s
syn_flag %d
is_dns_random %d
dns_type %d
is_edns %d
edns_len %d
is_edns_sec %d
\end{lstlisting}
\item[$\bullet$]Enfin, le malware créé un fichier \textbf{/proc/net/pktgen/pgctrl},
  dans lequel il écrit la chaîne de caractères "start".\\
\end{itemize}
La plupart des valeurs utilisées dans la configuration de pktgen sont obtenues
depuis les paramètres de la commande d'attaque.

\newpage

\subsection{Les autres modules}
\subsubsection{Monitor}
Le module Monitor s'occupe de vérifier que le module Bill reste en vie,
et de le relancer si il ne l'est plus.

\begin{algorithm}
  \begin{algorithmic}[1]
    \While {True}
    \State Écrit le pid du processus actuel dans le fichier
      \textbf{/tmp/moni.lod} et lock le fichier
    \State Récupère la localisation du fichier Beikong dans
      \textbf{/tmp/notify.file} et supprime le fichier
    \State Démarre un thread "CThreadMonGates" qui vérifie, toutes les 60
    secondes, \\que le fichier \textbf{/tmp/gates.lock} à un lock actif
    (et donc que le module Bill est toujours vivant)\\
    et relance le module Bill si ce n'est pas le cas
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\subsubsection{Systool}
Le module Systool est le module qui s'exécute lorsque l'exécutable se trouve
à la place d'un des outils système $netstat$, $lsof$, $ps$ ou $ss$.
Son rôle est de filtrer les sorties des outils qu'il remplace pour cacher
les parties qui pourraient révéler la présence du module Backdoor.
\begin{algorithm}
  \label{systool_code}
  \caption{Pseudo-code Systool}
  \begin{algorithmic}[1]
    \State Déduit le chemin de l'outil système original associé,
    en le dérivant du nom de l'exécutable actuel
      \State Si l'outil a été trouvé, le chemin complet de l'exécutable du module
      Backdoor est récupéré ainsi que la valeur du HiddenPort.
      L'outil système est alors exécuté avec les arguments passés en paramètres
      et la sortie est filtrée, n'affichant pas les références aux chemins et
      ports récupérés précédemment.
  \end{algorithmic}
\end{algorithm}

\subsubsection{Update}
La partie mise à jour du botnet est composée de deux morceaux :
une première partie, handler de la commande $DoUpdateCommand$, qui peut
être envoyée par le serveur C\&C et une deuxième qui fonctionne comme les
modules précédents, dans le sens où, si l'exécutable porte le nom
\textbf{update\_temporary}, alors il exécute la méthode $DoUpdate$ et
se termine ensuite.

% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]
{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]
{\algorithmiccase\ #1:}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\begin{algorithm}
  \label{update_code}
  \caption{Pseudo-code Update}
  \begin{algorithmic}[1]
    \Switch {update\_type}
      \Case {0x1}
        \State Download, move to libamplify.so, ReinitReadResources
          (libamplify.so)
      \EndCase
      \Case {0x5}
        \State Copy self, execute (update\_temporary, executes DoUpdate)
      \EndCase
      \Case {0x4}
        \State Download, move, execute if needed
      \EndCase
    \EndSwitch
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \label{doupdate_code}
  \caption{Pseudo-code DoUpate()}
  \begin{algorithmic}[1]
    \If {argc == 5}
      \State Prépare une update pour cfg1
    \EndIf
    \If {atoi(argv[1]) == 5}
      \State Modifie le fichier argv[3] en HardStart et SoftStart
    \EndIf
  \end{algorithmic}
\end{algorithm}
