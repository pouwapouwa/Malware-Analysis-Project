\chapter{Techniques d'analyses de malwares}

Lors de l'analyse d'un logiciel suspect, le code source est rarement disponible
et le seul support de travail est l'exécutable constituant le malware.
Pour appréhender son comportement, il est alors nécessaire de recourir à
l'utilisation de nombreux outils et astuces.\\

Il existe deux approches à l'étude d'exécutable: l'analyse statique
et l'analyse dynamique.\\
L'analyse statique consiste à examiner le binaire sans l'exécuter,
tandis que l'analyse dynamique se fait au cours de son exécution.
Ces deux approches sont en fait complémentaires et permettent d'obtenir
une vision d'ensemble sur le comportement du malware étudié.

\section{Analyse statique}

L'analyse statique est donc une méthode d'étude reposant uniquement
sur la lecture du binaire, sans l'exécuter. Celle-ci se base sur l'étude
des propriétés du binaire, de son code assembleur et permet de récupérer
des informations sur l'élément suspect sans risquer de contaminer ou
de modifier de manière involontaire son environnement de travail.

\subsection{Scanner anti-virus}

Une des premières et plus répandues techniques d'analyse,
quelles que soient les connaissances en informatiques,
est le passage par anti-virus. Celui-ci permet d'identifier,
neutraliser et même éliminer de nombreux logiciels malveillants.\\

Ils reposent principalement sur 3 techniques:
\begin{itemize}
\item[$\bullet$] {Comparaison des signatures virales;}
\item[$\bullet$] {Analyse du comportement des binaires suspectés;}
\item[$\bullet$] {Analyse de forme, à partir de règles regexp.\\}
\end{itemize}

Si le logiciel incriminé est identifié, alors celui-ci est connu et
reconnu depuis déjà un certain temps par les bases de données des anti-virus:
des études devraient être disponibles sur le net. \\

\subsection{Hash du sample et comparaison aux bases de données}

Les signatures utilisées par les anti-virus sont des identifiants propres
à chaque binaire, à une portion de code ou à un comportement particulier.
Les techniques et heuristiques utilisées dépendent des types de scanner
mais vont du simple hash de binaire aux algorithmes d'analyse
de comportement suspect. Cette dernière permet de trier les logiciels suspects
par familles, en fonction de leur comportement
(phishing, modification de registres, \ldots) mais aussi d'en analyser et
détecter certains qui sont alors encore inconnus, simplement par leurs actions.\\

Dans le cas de logiciels détectés comme malveillants mais encore inconnus,
de nouvelles signatures doivent être détectées. En effet, bien que
le comportement soit détecté comme suspect, celui-ci n'est pas encore
totalement étudié et peut présenté des principes des protections
(comme de réplication par exemple) qui sera nécessaire de déterminer
afin de développer de nouveaux outils et de débarrasser totalement
les victimes de leurs charges virales.\\

\subsection{Examen de l'exécutable}

Quel que soit le binaire, celui-ci doit fournir des informations relative
à son exécution, comme l'architecture supportée, la version (32/64 bits),
l'endianness, le point d'entrée (si celui-ci n'est pas le \textit{main}), \ldots
Ces informations ne sont pas stockées dans le corps du binaire mais
dans une en-tête, de manière différentes en fonction des types d'exécutables.
Mais les mêmes informations seront présentes, quels que soient
les supports utilisés.\\

Parmi les formats les plus répandus, il est aisé de retrouver les \textbf{ELF},
\textbf{PE} et \textbf{Mach-O}.\\

$\bullet$ ELF (Extensible Linking Format, ou plus formellement, Executable and
Linkable Format) est le format le plus présent dans les systèmes d'exploitation
de type Unix, excepté pour Mac OS X, permettant de représenter les exécutables,
les fichiers objets, les bibliothèques partagées comme les core dumps.\\

Les informations peuvent être récupérées par les fonctions \textit{file},
\textit{readelf}, \ldots
\begin{figure}[H]
\begin{verbatim}
yourself@cirdan:/tmp/HB3$ readelf -h ch23
En-tête ELF:
  Magique:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Classe:                            ELF32
  Données:                           complément à 2, système à octets de
poids faible d'abord (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  Version ABI:                       0
  Type:                              EXEC (fichier exécutable)
  Machine:                           Intel 80386
  Version:                           0x1
  Adresse du point d'entrée:         0x8048450
  Début des en-têtes de programme :  52 (octets dans le fichier)
  Début des en-têtes de section :    2404 (octets dans le fichier)
  [...]
\end{verbatim}
\caption {Données comprises dans l'en-tête d'un binaire ELF}
\end{figure}

D'autres informations peuvent être trouvées dans le binaire, notamment
les bibliothèques et fonctions importées/exportées.
Celles-ci sont extrêmement utiles pour l'analyse d'un binaire, afin d'avoir
une idée de son comportement sans l'exécuter.\\

$\bullet$ PE (Portable Executable) est le format de fichier des exécutable
et des bibliothèques sur les systèmes Windows. Il sert à décrire les binaires
(.exe), les bibliothèques dynamiques (.dll) et les pilotes (.sys).\\

$\bullet$ Mach-O pour les systèmes Mac OS X.\\

\subsection{Recherche de chaînes de caractères}

Une des manières d'analyser un exécutable est aussi d'observer les caractères
imprimables présents au milieu du code. En effet, si celui-ci n'est
pas obfusqué, les chaînes de caractères écrites "en brut" ou les fonctions
utilisées comme les sections peuvent être retrouvées assez facilement.
Avec la commande \textit{}, il est possible d'afficher toutes les chaînes
d'au moins 4 caractères.

\begin{figure}[H]
\begin{verbatim}
yourself@cirdan:/tmp/HB3$ strings ch23
/lib/ld-linux.so.2
__gmon_start__
libc.so.6
_IO_stdin_used
strncpy
__stack_chk_fail
printf
strlen
memset
__libc_start_main
[...]
Usage : %s <your name>
[...]
.init
.text
[...]
.data
.bss
[...]
main
_init
\end{verbatim}
\caption{Résultat de la commande \textit{strings} sur un binaire}
\end{figure}

\subsection{Packer et techniques de protection du binaire}

Mais l'analyse statique peut faire face à un certain nombre d'obstacles.
En effet, celle-ci repose essentiellement sur le principe de lecture de code
et en est donc entièrement dépendante.
Si le binaire se trouve, d'un quelconque manière, obfusqué, que son code est
modifié au cours de l'execution ou simplement que les données originales sont
altérées, alors sa lecture et sa compréhension en seront bien réduites.

Ainsi, il est possible de se retrouver face à un logiciel que l'on va qualifier
de "packé" (TODO: check) ou de "stripped".
Cette partie s'attardera uniquement sur ceux obfusquant le comportement
du binaire, même si ils n'ont pas tous vocation à le faire (comme ceux se basant
uniquement sur un principe de compression de données).\\

Une de ces techniques consiste à chiffrer la charge utile, malveillante
(le .text ou le .data par exemple, à condition d'avoir les droits d'écriture
dans la région). Le code suspect est alors composé de la
routine de déchiffrement et du payload chiffré. La clef, quant à elle,
pourra être stockée dans la routine de déchiffrement, le payload ou encore
récupérée depuis l'extérieur: depuis un fichier ou par une requête
vers un serveur.

De même, il existe plusieurs méthodes de chiffrement, allant du
XOR à celles utilisant les courbes elliptiques, du chiffrement unique
aux chiffrés imbriqués, bloc par bloc ou du payload entier
(voir figure~\ref{packer}).\\

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \draw[line width=.8pt] (0,0) -- (0,.8) -- (4,.8) -- (4,0) --cycle;
  \draw[line width=.8pt, pattern=checkerboard, pattern color=red!70]
  (1,0) -- (1,.8) -- (4,.8) -- (4,0) --cycle;
  \draw[<->, >=latex] (0,-.2) -- (1,-.2);
  \node[align=center] at (0.5,-.6){\shortstack{routine de\\déchiffrement}};
  \draw[->, >=latex] (0.65,.8) [out=90, in=90] to (2,.8);
  \node[align=center] at (1.7,1.8){
    \shortstack{déchiffre l'intégralité\\ du payload restant}};

  \draw[line width=.8pt] (6,0) -- (6,.8) -- (12,.8) -- (12,0) --cycle;
  \draw[line width=.8pt, pattern=checkerboard, pattern color=red!70]
  (7,0) -- (7,.8) -- (12,.8) -- (12,0) --cycle;
  \draw[line width=.8pt, fill=blue!70]
  (9.5,0) -- (9.5,.8) -- (12,.8) -- (12,0) --cycle;
  \draw[pattern=checkerboard, pattern color=red!70]
  (9.5,0) -- (9.5,.8) -- (12,.8) -- (12,0) --cycle;
  \draw[line width=.8pt, dashed] (12,.8) -- (13,.8);
  \draw[line width=.8pt, dashed] (12,0) -- (13,0);
  \draw[<->, >=latex] (6,-.2) -- (7,-.2);
  \node[align=center] at (6.5,-.6){\shortstack{routine de\\déchiffrement}};
  \draw[<->, >=latex] (8.5,-.2) -- (9.5,-.2);
  \node[align=center] at (9,-.6){\shortstack{routine de\\déchiffrement}};
  \draw[->, >=latex] (6.65,.8) [out=90, in=90] to (8,.8);
  \node[align=center] at (6.3,1.8){
    \shortstack{déchiffre la partie\\ \textcolor{red}{rouge} du payload }};
  \draw[->, >=latex] (9,.8) [out=90, in=90] to (10.5,.8);
  \node[align=center] at (9.7,1.8){
    \shortstack{déchiffre la partie\\ \textcolor{blue!70}{bleue} du payload}};
\end{tikzpicture}
\caption{\label{packer}Diffèrentes formes de packer chiffrant}
\end{figure}

Mais il existe aussi d'autres formes de packer,
comme ceux dits transformant qui vont, par exemple,
transformer leur code originel en code à fournir à une VM embarquée,
qui est donc incompréhensible sans l'exécuter ou connaître les instructions
 de l'architecture utilisée. (TODO: check)\\

Enfin, il existe aussi des techniques de protections, ralentissant ou
empêchant la rétro-ingénierie d'un binaire, de manière passive sur le code:\\

\begin{itemize}
\item[$\bullet$]{Détection de débugueur, de breakpoints
  (opcode 0xcc);}
\item[$\bullet$]{Anti-virtualisation (VM);}
\item[$\bullet$]{Anti-dumping;}
\item[$\bullet$]{Anti-tampering (vérification de checksum, \ldots);}
\item[$\bullet$]{\ldots\\}
\end{itemize}

\subsection{Analyse du code assembleur}

Le plus gros travail se porte sur la lecture de code.
Bien souvent, le sample a étudier ne fournit pas son code source
et il faut donc lire son code assembleur.\\

Celui-ci n'est pas donné nativement avec l'executable et il
est nécessaire de le récupérer à l'aide d'un désassembleur,
à partir du langage machine.
De nombreux outils existent, quelles que soient les plateformes utilisées:
\href{http://www.ollydbg.de/}{\textit{OllyDbg}} sur Windows,
\href{https://www.gnu.org/software/gdb/}{\textit{gdb}} et
\href{https://sourceware.org/binutils/docs-2.23/binutils/objdump.html}
     {\textit{objdump}} sur Linux, \ldots
Certains sont multiplateformes et proposent des services supplémentaires
pour la rétro-ingénirie. Parmi les plus connus, sont disponibles
\href{http://radare.org/r/}{\textit{Radare2}} et
\href{https://www.hex-rays.com/products/ida/index.shtml}{\textit{IdaPro}},
ce dernier proposant par exemple, un décompilateur pour les codes en C/C++.

\section{Analyse dynamique}

L'analyse dynamique, en opposition à l'analyse statique,
repose donc sur l'exécution du binaire suspect et l'observation
des diffèrentes actions et modifications apportées au système hôte.
Cette technique peut être dangereuse pour l'environnement de travail et
doit être correctement exécutée.

\subsection{Machine virtuelle}

L'élément à étudier peut ne pas correspondre à l'environnement de travail:
un malware Windows ne pourra affecter votre système si celui-ci est un GNU/Linux.
C'est pourquoi il est essentiel de mettre en place
un système de machine virtuelles.\\

De nombreux outils comme \href{http://www.vmware.com/fr.html}{\textit{VMware}}
ou \href{https://www.virtualbox.org/}{\textit{VirtualBox}} (libre)
permet de pouvoir virtualiser un grand nombre d'architectures,
sans pour autant modifier son environnement et offre la possibilité de choisir
, de configurer le système qui sera infecté (utile pour forcer certaines
versions du noyau, la persistance de certaines failles de sécurité, \ldots).\\
Un autre avantage à l'utilisation de machines virtuelles
est la capacité de pouvoir utiliser des snapshots. Ces "instantanés" vont
capturer l'état de la machine virtuelle (mémoire, configurations,
état des disques, \ldots) à un moment précis. Les modifications alors apportées
à la machine seront indépendantes du snapshots, préservant l'état de la VM
original. Si l'utilisateur a besoin de revenir en arrière sur ses actions,
il lui suffit de restaurer son snapshot, autant de fois que nécessaire.
Ceci est particulièrement utile lors de l'étude d'un malware, afin de pouvoir
étudier plusieurs fois la phase d'infection ou la première communication avec
un serveur C\&C, par exemple.\\

\subsection{Simulation de réseaux}

Un autre avantage à l'utilisation de machines virtuelles comme
environnement d'étude est la possibilité de relier plusieurs
machines virtuelles entre elles, comme dans un vrai réseau, tout en gardant
le contrôle sur chacune d'elles. Il est alors possible de créer totalement
son environnemet, de l'ordonner, de le gérer (création de server DNS
par exemple), afin d'adapter l'environnement d'infection au malware et
de pouvoir étudier les communications circulant sur le réseau.\\

\href{http://www.inetsim.org/index.html}{\textit{INetSim}} est un outil
Open-Source offrant ce service. Celui-ci permet de simuler
des services internet qui sont habiutellement utilisés par les malwares dans
un environnement de travail confiné. Parmi les modules proposés et qui peuvent
être utiles, il est possible de trouver la mise en place de service DNS, FTP,
HTTP, Daytime, \ldots

\subsection{Analyse de trafic}

Une fois l'environnement mis en place et que l'élémeent à analyser pense
communiquer normalement avec l'extérieur, il est bien souvent intéressant
d'observer et d'étudier ces communications. Ceci peut permettre d'inférer ou
de confirmer un comportement vu lors de la lecture de code, ou au contraire,
d'observer une interaction encore inconnue avec du malware avec
son environnement.\\

L'analyse de trafic ethernet peut être effectué à l'aide d'un outil
de capture de paquets libre comme
\href{http://www.tcpdump.org/}{\textit{tcpdump}} ou
\href{https://www.wireshark.org/}{\textit{Wireshark}}, disponibles sur
plusieurs architectures et systèmes. L'utilisateur peut alors utiliser un
filtre (BPF pour tcpdump, par exemple) ou les fonctionnalités de
\textit{Wireshark} afin de disséquer plus simplement les paquets,
de travailler sur des protocles déjà connus ou encore,
d'en découvrir et de les étudier.\\
Ce type d'étude peut être très pratique lors de la communication avec
un serveur C\&C.

\subsection{Listing des processus (ps / ProcessExplorer)}

\subsection{Tracing (strace / ProcMoon)}

\subsection{Debugging (gdb / x64dgb)}

TODO: Notes sur l'automatisation des parties basiques ? (Cuckoo, Limon) <-- Pour !
