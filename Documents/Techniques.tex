\chapter{Techniques d'analyses de malwares}

Lors de l'analyse d'un logiciel suspect, le code source est rarement disponible et le seul support de travail est l'exécutable constituant le malware. Pour appréhender son comportement, il est alors nécessaire de recourir à l'utilisation de nombreux outils et astuces.\\

Il existe deux approches à l'étude d'exécutable: l'analyse statique et l'analyse dynamique.\\
L'analyse statique consiste à examiner le binaire sans l'exécuter, tandis que l'analyse dynamique se fait au cours de son exécution. Ces deux approches sont en fait complémentaires et permettent d'obtenir une vision d'ensemble sur le comportement du malware étudié.

\section{Analyse statique}

L'analyse statique est donc une méthode d'étude de binaire reposant uniquement sur l'étude du binaire, sans l'exécuter. Celle-ci se base sur l'étude des propriétés du binaire, de son code assembleur et permet de récupérer des informations sur l'élément suspect sans risquer de contaminer ou de modifier de manière involontaire son environnement de travail.

\subsection{Scanner anti-virus}

Une des premières et plus répandues techniques d'analyse, quelles que soient les connaissances en informatiques, est le passage par anti-virus. Celui-ci permet d'identifier, neutraliser et même éliminer de nombreux logiciels malveillants.\\

Ils reposent principalement sur 3 techniques:
\begin{itemize}
\item[$\bullet$] {Comparaison des signatures virales;}
\item[$\bullet$] {Analyse du comportement des binaires suspectés;}
\item[$\bullet$] {Analyse de forme, à partir de règles regexp.\\}
\end{itemize}

Si le logiciel incriminé est identifié, alors celui-ci est connu et reconnu depuis déjà un certain temps par les bases de données des anti-virus: des études devraient être disponibles sur le net. \\

TODO: Sandbox ?

\subsection{Hash du sample et comparaison aux bases de données}

Les signatures utilisées par les anti-virus sont des identifiants propres à chaque binaire, à une portion de code ou à un comportement particulier. Les techniques et heuristiques utilisées dépendent des types de scanner mais vont du simple hash de binaire aux algorithmes d'analyse de comportement suspect. Cette dernière permet de trier les logiciels suspects par familles, en fonction de leur comportement (phishing, modification de registres, \ldots) mais aussi d'en analyser et détecter certains qui sont alors encore inconnus, simplement par leurs actions.\\

Dans le cas de logiciels détectés comme malveillants mais encore inconnus, de nouvelles signatures doivent être détectées. En effet, bien que le comportement soit détecté comme suspect, celui-ci n'est pas encore totalement étudié et peut présenté des principes des protections (comme de réplication par exemple) qui sera nécessaire de déterminer afin de développer de nouveaux outils et de débarrasser totalement les victimes de leurs charges virales.\\

TODO: False Positive/Negative ? VirusTotal ?

\subsection{Examen de l'exécutable}

Quel que soit le binaire, celui-ci doit fournir des informations relative à son exécution, comme l'architecture supportée, la version (32/64 bits), l'endianness, le point d'entrée (si celui-ci n'est pas le \textit{main}), \ldots
Ces informations ne sont pas stockées dans le corps du binaire mais dans une en-tête, de manière différentes en fonction des types d'exécutables. Mais les mêmes informations seront présentes, quels que soient les supports utilisés.\\

Parmi les formats les plus répandus, il est aisé de retrouver les \textbf{ELF}, \textbf{PE} et \textbf{Mach-O}.\\

$\bullet$ ELF (Extensible Linking Format, ou plus formellement, Executable and Linkable Format) est le format le plus présent dans les systèmes d'exploitation de type Unix, excepté pour Mac OS X, permettant de représenter les exécutables, les fichiers objets, les bibliothèques partagées comme les core dumps.\\

Les informations peuvent être récupérées par les fonctions \textit{file}, \textit{readelf}, \ldots
\begin{figure}[H]
\begin{verbatim}
yourself@cirdan:/tmp/HB3$ readelf -h ch23
En-tête ELF:
  Magique:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Classe:                            ELF32
  Données:                           complément à 2, système à octets de
poids faible d'abord (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  Version ABI:                       0
  Type:                              EXEC (fichier exécutable)
  Machine:                           Intel 80386
  Version:                           0x1
  Adresse du point d'entrée:         0x8048450
  Début des en-têtes de programme :  52 (octets dans le fichier)
  Début des en-têtes de section :    2404 (octets dans le fichier)
  [...]
\end{verbatim}
\caption {Données comprises dans l'en-tête d'un binaire ELF}
\end{figure}

D'autres informations peuvent être trouvées dans le binaire, notamment les bibliothèques et fonctions importées/exportées. Celles-ci sont extrêmement utiles pour l'analyse d'un binaire, afin d'avoir une idée de son comportement sans l'exécuter.\\

$\bullet$ PE (Portable Executable) est le format de fichier des exécutable et des bibliothèques sur les systèmes Windows. Il sert à décrire les binaires (.exe), les bibliothèques dynamiques (.dll) et les pilotes (.sys).\\

$\bullet$ Mach-O pour les systèmes Mac OS X.\\

\subsection{Recherche de chaînes de caractères}

Une des manières d'analyser un exécutable est aussi d'observer les caractères imprimables présents au milieu du code. En effet, si celui-ci n'est pas obfusqué, les chaînes de caractères écrites "en brut" ou les fonctions utilisées comme les sections peuvent être retrouvées assez facilement. Avec la commande \textit{}, il est possible d'afficher toutes les chaînes d'au moins 4 caractères.

\begin{figure}[H]
\begin{verbatim}
yourself@cirdan:/tmp/HB3$ strings ch23
/lib/ld-linux.so.2
__gmon_start__
libc.so.6
_IO_stdin_used
strncpy
__stack_chk_fail
printf
strlen
memset
__libc_start_main
[...]
Usage : %s <your name>
[...]
.init
.text
[...]
.data
.bss
[...]
main
_init
\end{verbatim}
\caption{Résultat de la commande \textit{strings} sur un binaire}
\end{figure}

\subsection{Identification de packing ou d'obfuscation}

Packer --$>$ Compression du logiciel et chiffrement. Chiffrement le plus simple est un XOR où la clef est inscrite dans le fichier. Chiffrement par bloc ou entier, diffèrent au début du main.
\\
+ Protection anti-reverse ? (Techniques anti-debug (détection de breakpoint: Int 3 0xCC, détection de débogueur), checksum)

\subsection{Analyse du code assembleur}

Outils: Radare2 / IDA Pro

\section{Analyse dynamique}

\subsection{Machine virtuelle (VirtualBox / VMWare)}

\begin{itemize}
\item {Mise en réseau}
\item {Snapshots}
\end{itemize}

\subsection{Tracing (strace / ProcMoon)}

\subsection{Listing des processus (ps / ProcessExplorer)}

\subsection{Simulation de réseaux (inetsim)}

\subsection{Analyse de trafic (tcpdump / wireshark)}

\subsection{Debugging (gdb / x64dgb)}

TODO: Notes sur l'automatisation des parties basiques ? (Cuckoo, Limon) <-- Pour !
