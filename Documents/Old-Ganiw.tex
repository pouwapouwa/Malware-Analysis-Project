\chapter{Ganiw}

\section{Introduction}

Le \textit{sample} porté à l'étude porte le doux nom de \textbf{Ganiw} mais est
aussi connu sous les nom de \textbf{BillGates} ou de combinaisons comme
\textbf{LINUX.BACKDOOR.GATES}.\\
Celui-ci semble avoir été étudié pour la première fois en Février 2014
dans un post de \textit{ValdikSS} sur le site \textit{\foreignlanguage{russian}{Хабрахабр}} : \textit{\href{https://habrahabr.ru/post/213973/}
{Studying the BillGates Linux Botnet}}\footnotemark,
mais continue tout de même à être étudié et à être actif.\\

Le malware Ganiw a été réalisé en C++ et pensé de manière à
être modulaire et portable.
Ce malware visait, à l'origine, uniquement les systèmes Linux,
mais a été porté plus tard sur les systèmes Windows\footnotemark.\\
Le choix des systèmes Linux n'est pas anodin, puisque le développement
toujours plus important des objets connectés dans l'"Internet of Things" (IoT).
En effet, une grande partie des systèmes embarqués prenant part à l'IoT fonctionnent
sur des distributions de GNU/Linux (voir OpenWrt\footnotemark ou le projet Yocto\footnotemark).
De plus, ces objets connectés sont, de manière générale, peu ou mal protégés
(absence de firewall, mots de passe faibles,\ldots) et non surveillés ou peu maintenus.
Ce sont donc des cibles de choix pour la création de \textit{botnets},
comme tente de le faire le malware \textbf{Ganiw}, pour mener des attaques
de types DDOS\footnotemark par exemple.\\

\footnotetext{Traduit depuis le russe}
\footnotetext{\url{https://thisissecurity.net/2015/09/30/when-elf-billgates-met-windows/}}
\footnotetext{Distributed Denial-Of-Service}
\footnotetext{\url{https://openwrt.org/}}
\footnotetext{\url{https://www.yoctoproject.org/}}

\subsection{Les outils}

Les principaux outils utilisés pour réaliser cette analyse ont été
le logiciel de virtualisation \href{https://www.virtualbox.org/}{\textit{VirtualBox}},
le debugger GNU \href{https://www.sourceware.org/gdb/}{\textit{GDB}},
l'utilitaire \href{https://github.com/strace/strace}{\textit{strace}},
l'analyseur de paquets \href{https://www.wireshark.org/}{\textit{Wireshark}},
le désassembleur \href{https://github.com/radare/radare2}{\textit{Radare2}} et
et le simulateur de services internet \href{http://www.inetsim.org/}{\textit{INetSim}}
qui sont des logiciels libres.\\

\section{Analyse}

Avant toute chose, voilà, ci-dessous, le SHA-256 du sample analysé :
\begin{lstlisting}
94f5fd896a526427a5ef1de37725e6eae3a06af3da098547f0adcfdd34fbfd2a
\end{lstlisting}

\subsection{Analyse basique}

Pour commencer, il est bon d'utiliser l'utilitaire $file$ pour en apprendre un
peu plus sur l'exécutable :
\begin{lstlisting}
ganiw:  ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked,
        for GNU/Linux 2.2.5, not stripped
\end{lstlisting}
C'est donc un exécutable au format ELF (Executable and Linkable Format) 32-bit pour Linux.\\
Il est intéressant de remarquer que l'exécutable est lié statiquement et surtout
qu'il n'a pas été strip (ce qui va nous permettre d'obtenir des informations
utiles telles que les noms de fonctions, méthodes ou variables potentiellement
utilisées par le programme et donc nous permettre de comprendre plus facilement
comment fonctionne le malware).\\

%TODO: ajouter partie analyse basique sur strings et symboles

Une analyse plus avancée est nécessaire pour avoir une idée concrète de ce que
fait le malware étudié. L'analyse continue donc avec Radare2 pour désassembler
le binaire et VirtualBox, GDB et strace pour obtenir des valeurs à des endroits
clés ou la liste des appels systèmes utilisés pendant l'exécution du malware.\\

Afin de faciliter la compréhension des relations qu'entretiennent les
différents modules entre eux, une figure récapitulative est présentée ci-dessous :\\
\begin{figure}[!h]

  \centering
  \input{Fig2}
  \label{recap}
  \caption{Fonctionnement schématique de Ganiw}

\end{figure}

\subsection{Main}

Le point d'entrée du binaire se fait au niveau de la fonction \textit{main}.
Sans trop entrer dans les détails, il est aisé de remarquer la structure
modulaire du malware~\ref{modulaire}.\\
\begin{figure}[!h]

  \centering
  \input{Fig1}
  \label{modulaire}
  \caption{Modules mis à disposition du malware}

\end{figure}

La fonction main commence donc par un ensemble de tests et d'initialisations de
variables globales, de mises en place du système.\\
\subsubsection{Close all files descriptor}
Tout d'abord, le malware va fermer les descripteurs de fichier compris entre
3 et 1023, laissant l'entrée standard, la sortie standard et l'erreur standard
(stdin, stdout et stderr) accessibles.
\subsubsection{Decode and init first variables set}
La deuxième partie consiste en l'initialisation de certaines variables globales,
depuis une chaîne de caractères quelque peu étrange. Dans le sample étudié,
celle-ci correspond à: \\
"681A1C1543072E0140491F162F0B55545C55775F55565E57745E5D545652705D5E55585F70585C
5659577D5\\C5F565C0423575B025A51720A56".\\

Une fonction de décodage (un simple XOR avec les octets de la clé),
avec la clé 'Google', est appliquée à cette chaîne. Le code C++ associé est
présent en annexes~\ref{C++}. Les informations obtenues sont alors stockées
dans des variables (figure~\ref{first_flag}), qui serviront à définir le
comportement futur du binaire.

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \multicolumn{1}{|l|}{\cellcolor{gray!20} g\_Iud77} &
    \multicolumn{3}{c|}{681A1C154 [\ldots] 0423575B025A51720A56} \\
    \hline
    \cellcolor{gray!20} g\_strMonitorFile & /usr/bin/.sshd &
    \cellcolor{gray!20} g\_uHiddenPt & 30000 \\
    \hline
    \cellcolor{gray!20} g\_iFileSize & 1223123 &
    \cellcolor{gray!20} g\_iHardStart & 772124 \\
    \hline
    \cellcolor{gray!20} g\_iSoftStart & 773152 &
    \cellcolor{gray!20} g\_strDoFun & 3010ad84e645e9 \\
    \hline
  \end{tabular}
  \caption{Valeurs des premières variables initialisées}
  \label{first_flag}
\end{figure}

\subsubsection{Get module full path}

Ensuite, le chemin absolu du binaire va être récupéré à l'aide de l'appel
système \textit{readlink} et du fichier
\textit{$\backslash$proc$\backslash$\textbf{XX}$\backslash$exe} où
\textit{\textbf{XX}} correspond au pid du processus courant.

\subsubsection{Integrity check}

Un test d'intégrité va être effectué à cette étape. La taille de l'exécutable
va être récupérée à l'aide de l'appel système \textit{stat} et va être comparée
à la valeur de la variable définie un peu plus tôt: \textit{g\_iFileSize}.
Si les deux tailles sont différentes, alors le binaire produit
une erreur de segmentation.

\subsubsection{Get Parent Path}

Puis, le chemin absolu vers le processus père de l'exécutable est récupéré,
de la même manière que précédemment, mais avec la fonction \textit{getppid}.

\subsubsection{Anti-debug protection}

Un test est de nouveau effectué, mais, cette fois-ci,
afin d'"empêcher" le débuggage du malware.
Si la chaîne de caractères "gdb" est présente dans le chemin absolu
du processus père, alors, le binaire produit une erreur de segmentation.

\subsubsection{Second variables set initialization}

La deuxième série d'initialisation de variables n'est pas obfusquée:
le nom des variables et leurs contenus sont présentés
dans le tableau suivant (figure~\ref{second_flag}).

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strSN & DBSecuritySpt &
    \cellcolor{gray!20} g\_strML & /tmp/moni.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDSN & selinux &
    \cellcolor{gray!20} g\_strGL & /tmp/gates.lod \\
    \hline
    \cellcolor{gray!20} g\_strBDG & getty & \multicolumn{2}{c|}{}\\
    \hline
  \end{tabular}
  \caption{Valeurs des secondes variables initialisées}
  \label{second_flag}
\end{figure}

\subsubsection{Check of gates type}

Cette étape va définir le comportement du binaire,
en fonction de son chemin absolu.
En effet, celui-ci va être comparé au différentes valeurs présentes
dans les variables définis plus tôt, afin de définir le contenu d'une
nouvelle variable: \textit{g\_iGatesType} (voir figure~\ref{gates_type}).

\begin{algorithm}[H]
  \label{gates_type}
  \caption{Initialisation de la variable g\_iGatesType}
  \begin{algorithmic}[1]

    \State {path := GetModuleFullPath}
    \State {uaSystools := ['/bin/netstat', '/bin/lsof', '/bin/ps', '/bin/ss', \\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/bin/netstat',
        '/usr/bin/lsof', '/usr/bin/ps', '/usr/bin/ss',\\
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '/usr/sbin/netstat',
        '/usr/sbin/lsof', '/usr/sbin/ps', '/usr/sbin/ss']}
    \State {}
    \If {(path = g\_strMonitorFile)} \State {g\_iGatesType := 0}
    \Comment Module MainMonitor
    \Else
    \If {(path = "/usr/bin/bsd-port/getty")} \Comment Issu de g\_strBDG
    \State {g\_iGatesType := 2} \Comment Module MainBackdoor
    \Else
    \If {(path $\in$ uaSystools)} \State {g\_iGatesType := 3}
    \Comment Module MainSystool
    \Else \State {g\_iGatesType := 1} \Comment Module MainBeikong
    \EndIf \EndIf \EndIf

  \end{algorithmic}
\end{algorithm}

\subsubsection{Decode and init third variables set}

Tout comme lors de l'étape \textbf{Decode and init first variables set},
un ensemble de variables va être initialisé en fonction d'une valeur,
rentrée en clair dans le binaire.\\
En ce qui concerne ces variables, il y a deux configurations possibles :
une première configuration pour le module Backdoor et une seconde
pour le module Beikong. Ces deux configurations sont stockées chiffrées
(à l'aide de l'algorithme de chiffrement RSA [à préciser]) dans le binaire
et sont déchiffrées avant d'être parsées. Un test d'integrité est fait
sur les configurations en comparant la valeur des 14 premiers octets du
hash MD5 de la chaîne de caractères contenant les deux configurations chiffrées
à la valeur stockée dans la variable globale g\_strDoFun.\\
Ces deux configurations sont les suivantes :

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strConnTgts & 115.28.206.48 &
    \cellcolor{gray!20} g\_iIsService & 1 \\
    \hline
    \cellcolor{gray!20} g\_iGatsPort & 25000 &
    \cellcolor{gray!20} g\_strForceNote & -== Love AV ==- \\
    \hline
    \cellcolor{gray!20} g\_iGatsFx & 1 & \cellcolor{gray!20} g\_iDoBackdoor & 1 \\
    \hline
  \end{tabular}
  \caption{Valeurs des dernières variables globales initialisés
    pour le module Bill}
  \label{third_flag}
\end{figure}

\begin{figure}[h!]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline
    \cellcolor{gray!20} g\_strConnTgts & www.i0cc.com &
    \cellcolor{gray!20} g\_iIsService & 1 \\
    \hline
    \cellcolor{gray!20} g\_iGatsPort & 6001 &
    \cellcolor{gray!20} g\_strForceNote & -== Love AV ==- \\
    \hline
    \cellcolor{gray!20} g\_iGatsFx & 1 &
    \cellcolor{gray!20} g\_iDoBackdoor & 1 \\
    \hline
  \end{tabular}
  \caption{Valeurs des dernières variables globales
    initialisés pour le module Backdoor}
  \label{third_flag}
\end{figure}


\subsubsection{Module choice}

Enfin, le malware va charger un des modules, en fonction de la valeur de la
variable \textit{g\_iGatesType}, ou lancer une mise à jour si l'exécutable
porte le nom \textbf{update\_temporary}.\\
Tous les modules à l'exception des modules Monitor et Systool commencent par
invoquer la fonction $daemon$ (avec les arguements (1, 0)) qui détache le
processus actuel du terminal actif en effectuant un $fork$ puis
en redirigeant stdin, stderr et stdout dans /dev/null.

Le pseudo-code de la fonction main, est consultable en annexes~\ref{main_algo}.\\

\subsection{Module Beikong/Bill}

Le module Beikong (ou Bill) est le module d'installation mais également
le premier module principal du botnet. Son rôle est, d'abord, de nettoyer
le système en arrêtant et supprimant les potentielles instances de lui-même
qui tournerait déjà sur le système, puis de mettre en place le démarrage
automatique de son exécutable au lancement du système et, enfin,
de réinstaller et démarrer les modules Backdoor et Monitor.
Il communique également avec un serveur "command and control" (C\&C).
\newline

Pseudo-code :
\begin{itemize}
\item Arrête le module Monitor
\item Arrête le module Bill
\item Si la configuration le précise (booléen IsService à Vrai), créer un script
  i\textbf{/etc/init.d/DbSecuritySpt} et des liens symboliques
  \textbf{/etc/rc$i$.d/S97DbSecuritySpt} (avec $i$ allant de 1 à 5)
  vers ce script, permettant de lancer l'exécutable actuel au démarrage
\item Si la configuration le précise (booléen DoBackdoor à Vrai),
  arrête le module Backdoor et le réinstalle
  (dans \textbf{/usr/bin/bsd-port/getty}) et le relance
\item Si l'exécutable est exécuté en tant que root, indique
  la localisation du fichier du module Beikong dans
  \textbf{/tmp/notify.file} et installe/lance le module Monitor
  (dans \textbf{/usr/bin/.sshd})
\item Exécute MainProcess()
\end{itemize}

\subsection{Module Backdoor}
Le module Backdoor est le deuxième module principal du botnet. Il s'occupe
de remplacer quelques outils systèmes classiques par son exécutable pour
cacher ses traces. Il communique lui aussi avec un serveur C\&C.\newline

Pseudo-code :
\begin{itemize}
\item Inscrit le pid du processus actuel dans le fichier
  \textbf{/usr/bin/bsd-port/getty.lock} et lock le fichier
\item Créer un script \textbf{/etc/init.d/selinux} et des liens symboliques
  \textbf{/etc/rc$i$.d/S99selinux} (avec $i$ allant de 1 à 5) vers ce script,
  permettant de lancer l'exécutable actuel
  (\textbf{/usr/bin/bsd-port/getty}) au démarrage
\item Copie et remplace les outils systèmes $netstat$, $lsof$, $ps$ et $ss$
  dans les dossiers \textbf{/bin/}, \textbf{/usr/bin/} et \textbf{/usr/sbin/}
\item Exécute MainProcess()
\end{itemize}

\subsection{MainProcess, capacité d'attaque et
  communication avec les serveurs C\&C}
Dans les modules précédents on finit dans les deux cas par exécuter
la fonction MainProcess(). Cette fonction constitue la partie active du botnet.
\newline

Pseudo-code de MainProcess :
\begin{itemize}
\item Initialise DNSCache (parse \textbf{/etc/resolv.conf}, utilisé pour la
  résolution de noms de domaine)
\item Initialise ConfigDoing (parse \textbf{conf.n} qui se trouve
  dans le dossier courant)
\item Initialise CmdDoing (parse \textbf{cmd.n} qui se trouve
  dans le dossier courant)
\item Initialise StatBase (GetOS, GetCpuSpd, CpuUse, NetUse, GetMemSize)
\item Initialise ProvinceDns (liste de DNS utilisés pour l'amplification)
\item Essaye de charger \textbf{/usr/lib/xpacket.ko} avec
  system("insmod /usr/lib/xpacket.ko")
\item Initialise CAmpResource (en lisant le fichier
  \textbf{/usr/lib/libamplify.so})
\item Initialise CManager (démarrage des threads principaux
  et de la communication au C\&C)
\end{itemize}

\subsubsection{Communication avec le serveur C\&C}
Le botnet à besoin de communiquer avec un ou plusieurs serveurs C\&C pour
pouvoir agir.\\
La communication au C\&C peut se faire dans les deux sens : soit le client
se connecte au serveur C\&C, soit le serveur C\&C se connecte au client.
Le choix est fait en fonction du paramètre de configuration g\_GatsIsFx;
dans notre cas le client se connecte au serveur (ce qui est préférable
étant donné que beaucoup de routeurs font du NAT par défaut,
ce qui empêche les connexions sur des ports arbitraires depuis l'extérieur).
\newline

La communication s'effectue par le biais d'une ou plusieurs connexions TCP/IP
en direction ou depuis les IPs définies dans g\_strConnTgts
et sur le port défini dans g\_iGatsPort.\newline
Dans le cas où g\_iGatsIsFX est vrai, un thread représenté par
la classe "CThreadFXConnection" est crée pour établir et gérer chaque connection
aux différents serveurs C\&C.\newline
En revanche, dans le cas où g\_iGatsIsFX est faux, alors le module exécute
la méthode CManager$::$ZXMainProcess() qui va simplement créer une socket,
la bind sur le port g\_iGatsPort et se mettre en écoute, de manière à accepter
toutes les connexions entrantes sur ce port.\newline
Dans les deux cas, le module fini par appeler la méthode
CManager$::$ConnectionProcess() qui s'occupe de communiquer avec le serveur C\&C
et de faire passer les commandes reçues au thread en charge de l'exécution des
commandes, par le biais d'un objet de type
"CThreadSignaledMessageList$<$CCmdMsg$>$".\newline

Le protocole de discussion est simple, après avoir établi une connexion avec un
serveur C\&C, le client commence par envoyer des informations sur lui-même
(à savoir, une copie de son objet CConfigDoing actuel) ainsi que sur la machine
(telles que le nombre de coeurs présents sur la machine,
la fréquence de fonctionnement des coeurs, la quantité de RAM disponible sur
la machine, la version du noyau linux ou encore l'IP de la machine
dans le réseau local) en appelant la méthode CManager$::$MakeInitResponse().
Ensuite le client se met en attente de commandes en appelant la méthode
CManager$::$RecvCommand().\\

Les paquets de commande envoyés par le serveur C\&C sont de la forme :\\
\newline
\begin{bytefield}[bitwidth=3.5em]{8}
\bitheader{0-7} \\
\bitbox{4}{ID de la commande} & \bitbox{4}{Taille du champ paramètres} &
\bitbox{4}{Paramètres}
\end{bytefield} \\

Plusieurs commandes sont disponibles :
\begin{figure}[h!]
 \centering
 \begin{tabular}{|l|c|}
    \hline
    \cellcolor{gray!20} Id de la commande & \cellcolor{gray!20} Description \\
    \hline
    \cellcolor{gray!0} 0x1 & Démarre une attaque sur une ou plusieurs cibles \\
    \hline
    \cellcolor{gray!0} 0x2 & Arrête les attaques ou mises à jour en cours \\
    \hline
    \cellcolor{gray!0} 0x3 & Modifie la configuration du module \\
    \hline
    \cellcolor{gray!0} 0x5 & Démarre une mise à jour du client \\
    \hline
    \cellcolor{gray!0} 0x7 & Mets à jour l'actuel objet de type CCmdDoing \\
    \hline
    \cellcolor{gray!0} 0x8 & DoFakeDetect (??) \\
    \hline
    \cellcolor{gray!0} 0x9 &  Demande l'accès à un reverse shell en tant
    que root sur le client \\
    \hline
  \end{tabular}
  \caption{Liste des commandes disponibles}
  \label{cmds}
\end{figure}
\ \\
Le thread représenté par la classe "CThreadTaskGates" s'occupe, en parallèle,
d'exécuter la liste de commandes qu'il peut trouver dans la liste
des commandes mentionnée précédemment. Il vérifie d'abord que des commandes
ont été reçues et, si c'est le cas, exécute le handler associé à la commande,
puis recommence indéfiniment.\newline

\subsubsection{Attaques normales}
Le botnet peut mener plusieurs attaques de type DDOS en utilisant
des sockets "raw" depuis le mode utilisateur.\newline
Tout se déroule dans la méthode CThreadAtkCtrl$::$StartNormalSubTask().\newline
On compte 11 types d'attaques dans ce sample, dont 3 qui ne semblent pas être
totalement implémentées:
\begin{itemize}
\item CAttackCompress : Attaque TCP flood avec header TCP choisi
  (utile pour les fragment attack / Teardrop)
\item CAttackSyn : Attaque TCP type SYN flood
\item CAttackUdp : Attaque type UDP packet flood
\item CAttackDns : Attaque type DNS flood (pour l'attaque de sous-domaines DNS)
\item CAttackAmp : Attaque type DNS amplification
\item CAttackPrx : Attaque de type indéterminé faisant usage de requêtes DNS
\item CAttackIcmp : Attaque type ICMP-Request flood
\item CTcpAttack : Attaque type TCP flood
  (connexion, envoi de 5000 octets, déconnexion)
\item CAttackCc : Attaque pas entièrement implémentée
  (une attaque de type HTTP request flood d'après les seules traces visibles)
\item CAttackIe : Attaque non implémentée
\item CAttackTns : Attaque non implémentée
\end{itemize}
\ \\
Le déroulement des attaques est similaire pour toutes ces attaques.
Les classes sont toutes descendantes d'une classe CPacketAttack qui implémente
des méthodes virtuelles $UpdateCurVariant$ (chargée de mettre à jours certains
paramètres tels que l'IP source, le port source ou le numéro de séquence
du prochain paquet), $MakePacket$ (qui s'occupe de forger entièrement
le paquet à envoyer) et $Do$ (qui exécute une itération de l'attaque,
en appelant $UpdateCurVariant$, $MakePacket$, $SendPacket$ typiquement)
que chaque classe d'attaque personnalise en fonction des besoins.\newline

\subsubsection{Attaques noyaux}
Le botnet est également capable de lancer des attaques depuis le noyau grâce à
l'outil pktgen, qui permet de générer des paquets très rapidement.\newline
Tout se déroule dans la méthode CThreadAtkCtrl$::$StartKernalSubTask()
(et la faute de frappe pour Kernal n'est pas de nous).
La configuration de l'outil se fait en trois étapes :\newline
\begin{itemize}
\item Pour chaque coeur du CPU de la machine,
  un fichier \textbf{/proc/net/pktgen/kpktgend\_$i$} (où $i$ est
  le numéro du coeur) est crée. Le contenu de ces fichiers est le suivant :
\begin{lstlisting}
rem_device_all
add_device eth%d
max_before_softirq 10000
\end{lstlisting}
\item Pour chaque coeur du CPU de la machine, un fichier
  \textbf{/proc/net/pktgen/eth$i$} (où $i$ est le numéro du coeur) est crée.
  Le contenu de ces fichiers est le suivant :
\begin{lstlisting}
count 0
clone_skb 0
delay 0
TXSIZE_RND
min_pkt_size %d
max_pkt_size %d
IPSRC_RND
src_min %s
src_max %s
UDPSRC_RND
udp_src_min %d
udp_src_max %d
dst %s
udp_dst_min %d
udp_dst_max %d
dst_mac %02x:%02x:%02x:%02x:%02x:%02x //adresse MAC de la passerelle obtenu de g_statBase
is_multi %d //nombre de cibles
multi_dst %s //si l'attaque se fait vers plusieurs adresses, elles sont specifiees ici
pkt_type %d
dns_domain %s
syn_flag %d
is_dns_random %d
dns_type %d
is_edns %d
edns_len %d
is_edns_sec %d
\end{lstlisting}
\item Enfin, le malware créer un fichier \textbf{/proc/net/pktgen/pgctrl},
  dans lequel il écrit la chaîne de caractères "start".
\end{itemize}
La plupart des valeurs utilisées dans la configuration de pktgen sont obtenues
depuis les paramètres de la commande d'attaque.

\subsection{Les autres modules}
\subsubsection{Monitor}
Le module Monitor s'occupe de vérifier que le module Bill reste en vie,
et de le relancer si il ne l'est plus.

Pseudo-code :
\begin{itemize}
\item Écrit le pid du processus actuel dans le fichier \textbf{/tmp/moni.lod}
  et lock le fichier
\item Récupère la localisation du fichier Beikong dans \textbf{/tmp/notify.file}
  et supprime le fichier
\item Démarre un thread "CThreadMonGates" qui vérifie, toutes les 60 secondes,
  que le fichier \textbf{/tmp/gates.lock} à un lock actif (et donc
  que le module Bill est toujours vivant) et relance le module Bill
  si ce n'est pas le cas
\item Boucle à l'infini
\end{itemize}

\subsubsection{Systool}
Le module Systool est le module qui s'exécute lorsque l'exécutable se trouve
à la place d'un des outils systèmes $netstat$, $lsof$, $ps$ ou $ss$.
Son rôle est de filtrer les sorties des outils qu'il remplace pour cacher
les parties qui révèlent la présence du module Backdoor.\newline

Pseudo-code :
\begin{itemize}
\item Déduit le chemin de l'outil système original associé, en le dérivant
  du nom de l'exécutable actuel
\item Si l'outil a été trouvé, on récupère le chemin complet de l'exécutable
  du module Backdoor ainsi que la valeur du HiddenPort, on exécute
  l'outil système avec les arguments passés en paramètres et on filtre la sortie
  en n'affichant pas les références aux chemin et port récupérer précédemment
\end{itemize}

\subsubsection{Update}
La partie mise à jour du botnet est composée de deux morceaux :
un premier morceau qui est le handler de la commande $DoUpdateCommand$ qui peut
être envoyée par le serveur C\&C et une deuxième partie qui fonctionne comme les
modules précédents, dans le sens où, si l'exécutable porte le nom
\textbf{update\_temporary}, alors il exécute la méthode $DoUpdate$ et
se termine ensuite.

Pseudo-code DoUpdateCommand :
\begin{itemize}
\item Méthode 1 : Download, move to libamplify.so, ReinitReadResources
  (libamplify.so)
\item Méthode 5 : Copy self, execute (update\_temporary, executes DoUpdate)
\item Méthode 4 : Download, move, execute if needed
\end{itemize}

Pseudo-code DoUpdate :
\begin{itemize}
\item Si argc == 5, on prépare une update pour cfg1
\item Si atoi(argv[1] == 5) (cas principal), on modifie le fichier argv[3] en
  HardStart et SoftStart
\end{itemize}
